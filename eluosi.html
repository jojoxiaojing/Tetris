<html>
<head>
    <title></title>
    <style type="text/css">
        #main_canvas
        {
            border: 3px solid black;
        }
        #sign_canvas
        {
            display: none;
        }
        .preloadImg
        {
            display: none;
        }
    </style>

    <script src="block.js" >
    </script>
    <script type="text/javascript">
        //constant
        var GAME_AREA_WIDTH = 10;
        var GAME_AREA_HEIGHT = 18;
        var GAME_AREA_TOP = 10;
        var GAME_AREA_LEFT = 10;

        var NEXT_BLOCK_AREA_TOP = GAME_AREA_TOP + 50;
        var NEXT_BLOCK_AREA_LEFT = GAME_AREA_LEFT + GAME_AREA_WIDTH * BLOCK_SIZE + 50;
        var NEXT_BLOCK_AREA_WIDTH = 6 * BLOCK_SIZE;
        var NEXT_BLOCK_AREA_HEIGHT = 5 * BLOCK_SIZE;
        var NEXT_BLOCK_X = NEXT_BLOCK_AREA_LEFT + BLOCK_SIZE * 2;
        var NEXT_BLOCK_Y = NEXT_BLOCK_AREA_TOP + BLOCK_SIZE * 2;


        //canvas
        var main_canvas;
        var main_context;
        var MAIN_CONTEXT_WIDTH = 400;
        var MAIN_CONTEXT_HEIGHT = 380;
        var sign_canvas;
        var sign_context;

        var bitmapArray = new Array();  //0为空,1~7为颜色


        var currentBlock;
        var nextBlock;
        var blockPositionX;
        var blockPositionY;
        //顺序为从左上至右下，row=0为最上一层
        function getBitMapInfo(row,column)
        {
            if (row < GAME_AREA_HEIGHT && column < GAME_AREA_WIDTH )
            {
                return bitmapArray[row * GAME_AREA_WIDTH + column];
            }
            else
            {
                return 0;
            }
        }
        function setBitMapInfo(row,column,color)
        {
            if (row < GAME_AREA_HEIGHT && column < GAME_AREA_WIDTH )
            {
                bitmapArray[row * GAME_AREA_WIDTH + column] = color;
            }
            else
            {
                return 0;
            }
        }

        function init()
        {
            //canvas
            main_canvas = document.getElementById("main_canvas");
            main_context = main_canvas.getContext("2d");
            sign_canvas = document.getElementById("sign_canvas");
            sign_context = sign_canvas.getContext("2d");

            //bitmapArray
            for(var i = 0; i < GAME_AREA_WIDTH * GAME_AREA_HEIGHT; i++)
            {
                bitmapArray[i] = 0;
            }

            nextBlock = getRandomBlock();
            getNextBlock();

            redraw();

            //key listener
            window.addEventListener('keydown',handleKeyDown,false);
//            main_canvas.addEventListener('keydown',handleKeyDown,false);
        }
        function getNextBlock()
        {
            currentBlock = nextBlock;
            nextBlock = getRandomBlock();
            blockPositionX = parseInt(GAME_AREA_WIDTH / 2 - 1);
            blockPositionY = 0;
        }

        ////////////////////////////////////
        //KeyBoard Handler
        function handleKeyDown(event)
        {

            var keyCode;
            if (event == null)
            {
                keyCode = window.event.keyCode;
                if(keyCode >= 37 && keyCode <= 40)
                {
                    window.event.preventDefault();
                }
            }
            else
            {
                keyCode = event.keyCode;
                if(keyCode >= 37 && keyCode <= 40)
                {
                    event.preventDefault();
                }
            }

            switch(keyCode)
            {
                case 37:        //Left
                        handleLeftKey();
//                      alert("Left");
                        break;
                case 38:        //Top
                        handleUpKey();
//                      alert("Top");
                    break;
                case 39:        //Right
                        handleRightKey();
//                      alert("Right");
                    break;
                case 40:        //Down
                        handleDownKey();
//                      alert("Down");
                    break;
            }
        }
        function handleUpKey()
        {
            currentBlock.rotate();
            if(detectConflict(0,0))
            {
                currentBlock.rotateBack();
            }
            redraw();
        }
        function detectConflict(offsetX,offsetY)
        {
            var bLeft = getBlockLeft(currentBlock);
            var bRight = getBlockRight(currentBlock);
            var bBottom = getBlockBottom(currentBlock);

            if(parseInt(bRight + blockPositionX + offsetX) >= parseInt(GAME_AREA_WIDTH))
            {
                return true;
            }
            if(parseInt(bLeft + blockPositionX + offsetX) < parseInt(0))
            {
                return true;
            }
            if (parseInt(bBottom + blockPositionY + offsetY) >= parseInt(GAME_AREA_HEIGHT))
            {
                return true;
            }
            for (var i = 0; i < currentBlock.points.length; i++)
            {
                var bX = blockPositionX + currentBlock.points[i].x + offsetX;
                var bY = blockPositionY + currentBlock.points[i].y + offsetY;
                if (getBitMapInfo(bY, bX) != 0)
                {
                    return true;
                }

            }
            return false;

        }
        function handleDownKey()
        {
            moveCurrentBlock(0,1);

        }
        function handleLeftKey()
        {
            moveCurrentBlock(-1,0);

        }
        function handleRightKey()
        {
            moveCurrentBlock(1,0);

        }


        ////////////////////////////////////
        //Block Movement
        function moveCurrentBlock(mX, mY)       //mX = 1 or -1, mY = 1
        {
            if (mX == 1 && mY == 0)             //Move Right
            {
                if (!detectConflict(1,0))
                {
                    blockPositionX += 1;
                    redraw();
                }
            }
            else if (mX == -1 && mY == 0)       //Move Left
            {
                if (!detectConflict(-1,0))
                {
                    blockPositionX -= 1;
                    redraw();
                }
            }
            else if (mX == 0 && mY == 1)        //Move Down
            {
                if (detectConflict(0,1))
                {
                    addBlockToBitmap();
                    getNextBlock();
                    redraw();
                }
                else
                {
                    blockPositionY += 1;
                    redraw();
                }
            }
        }
        function addBlockToBitmap()
        {
            for(var i = 0; i < currentBlock.points.length; i++)
            {
                var point = currentBlock.points[i];
                var x = point.x;
                var y = point.y;
                setBitMapInfo(blockPositionY + y, blockPositionX + x, currentBlock.color);

            }
        }

        function drawCurrentBlock()
        {
            drawBlock(GAME_AREA_LEFT + blockPositionX * BLOCK_SIZE, GAME_AREA_TOP + blockPositionY * BLOCK_SIZE, currentBlock, main_context);
        }

        function redraw()
        {
            main_context.fillRect(0,0,MAIN_CONTEXT_WIDTH,MAIN_CONTEXT_HEIGHT);
            //game area

            main_context.clearRect(GAME_AREA_LEFT, GAME_AREA_TOP,GAME_AREA_WIDTH * BLOCK_SIZE,GAME_AREA_HEIGHT * BLOCK_SIZE);

            for (var row = 0; row < GAME_AREA_HEIGHT; row++)
            {
                for (var column = 0; column < GAME_AREA_WIDTH; column++)
                {
                    var color = getBitMapInfo(row,column);
                    if(color != 0)
                    {
                        var y = GAME_AREA_TOP + row * BLOCK_SIZE;
                        var x = GAME_AREA_LEFT + column * BLOCK_SIZE;
                        preBitMapImg(color,x,y,main_context);
                    }
                }
            }

            //next area
            main_context.clearRect(NEXT_BLOCK_AREA_LEFT, NEXT_BLOCK_AREA_TOP, NEXT_BLOCK_AREA_WIDTH, NEXT_BLOCK_AREA_HEIGHT);
            drawBlock(NEXT_BLOCK_X, NEXT_BLOCK_Y, nextBlock, main_context);

            //currentBlock
            drawCurrentBlock();
        }

        function preBitMapImg(color,x,y,context)
        {
            var imgName = getColorImage(color);
            var img = new Image();
            img.src = imgName;
            if (img.complete)
            {
                context.drawImage(img,x, y, BLOCK_SIZE, BLOCK_SIZE);
                return;
            }
            img.onload = function()
            {
                context.drawImage(img,x, y, BLOCK_SIZE, BLOCK_SIZE);
            };
        }


    </script>
</head>
<body onload="init()">

    <canvas width="400" height="380" id="main_canvas">
        Your browser doesn't support canvas, please change the browser.
    </canvas>
    <canvas width="200" height="100" id="sign_canvas">
        Your browser doesn't support canvas, please change the browser.
    </canvas>


    <!--预读取图片，防止游戏图片加载缓慢-->
    <img class="preloadImg" src="img/block_color_1.png" />
    <img class="preloadImg" src="img/block_color_2.png" />
    <img class="preloadImg" src="img/block_color_3.png" />
    <img class="preloadImg" src="img/block_color_4.png" />
    <img class="preloadImg" src="img/block_color_5.png" />
    <img class="preloadImg" src="img/block_color_6.png" />
    <img class="preloadImg" src="img/block_color_7.png" />


</body>
</html>