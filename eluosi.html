<html>
<head>
    <title></title>
    <style type="text/css">
        #main_canvas
        {
            border: 3px solid black;
        }
        #sign_canvas
        {
            display: none;
        }
        .preloadImg
        {
            display: none;
        }
    </style>

    <script src="block.js" >
    </script>
    <script type="text/javascript">
        //constant
        var GAME_AREA_WIDTH = 10;
        var GAME_AREA_HEIGHT = 18;
        var GAME_AREA_TOP = 10;
        var GAME_AREA_LEFT = 10;

        //Score
        var SCORE_TEXT_X = GAME_AREA_LEFT + GAME_AREA_WIDTH * BLOCK_SIZE + 100 ;
        var SCORE_TEXT_Y = GAME_AREA_TOP + 10;
        var SCORE_NUMBER_X = GAME_AREA_LEFT + GAME_AREA_WIDTH * BLOCK_SIZE + 100 ;
        var SCORE_NUMBER_Y = GAME_AREA_TOP + 30;

        //Next
        var NEXT_BLOCK_AREA_TOP = GAME_AREA_TOP + 50;
        var NEXT_BLOCK_AREA_LEFT = GAME_AREA_LEFT + GAME_AREA_WIDTH * BLOCK_SIZE + 50;
        var NEXT_BLOCK_AREA_WIDTH = 6 * BLOCK_SIZE;
        var NEXT_BLOCK_AREA_HEIGHT = 5 * BLOCK_SIZE;
        var NEXT_BLOCK_X = NEXT_BLOCK_AREA_LEFT + BLOCK_SIZE * 2;
        var NEXT_BLOCK_Y = NEXT_BLOCK_AREA_TOP + BLOCK_SIZE * 2;

        //canvas
        var main_canvas;
        var main_context;
        var MAIN_CONTEXT_WIDTH = 400;
        var MAIN_CONTEXT_HEIGHT = 380;
        var sign_canvas;
        var sign_context;

        var currentBlock;
        var nextBlock;
        var blockPositionX;
        var blockPositionY;
        var currentScore;

        var fFalling;
        var fallingCycleTag;
        var currentFallingInterval;
        var FALL_INTERVAL_CHANGE_RATE = 0.9;

        var bitmapArray = new Array();  //0为空,1~7为颜色,-1为消去
        //Bit Map
        //顺序为从左上至右下，row=0为最上一层
        function getBitMapInfo(row,column)
        {
            if (row < GAME_AREA_HEIGHT && column < GAME_AREA_WIDTH )
            {
                return bitmapArray[row * GAME_AREA_WIDTH + column];
            }
            else
            {
                return 0;
            }
        }
        function setBitMapInfo(row,column,color)
        {
            if (row < GAME_AREA_HEIGHT && column < GAME_AREA_WIDTH )
            {
                bitmapArray[row * GAME_AREA_WIDTH + column] = color;
            }
            else
            {
                return 0;
            }
        }

        function init()
        {
            //canvas
            main_canvas = document.getElementById("main_canvas");
            main_context = main_canvas.getContext("2d");
            sign_canvas = document.getElementById("sign_canvas");
            sign_context = sign_canvas.getContext("2d");

            startInit();
        }

        ////////////////////////////////////////////////////////////////////////
        //Start Scene
        function startInit()
        {
            drawPreScene();
            main_canvas.addEventListener('mousemove',startMouseMoveDetect,false)
            main_canvas.addEventListener('mouseup',startMouseUpDetect,false);
            fMouseInStartButton = false;
        }
        function mouseInStartButton(x,y)
        {
            var distantX, distantY;
            distantX = x - MAIN_CONTEXT_WIDTH / 2;
            distantY = y - MAIN_CONTEXT_HEIGHT / 2;

            if (distantX < 50 && distantX > -50 && distantY < 20 && distantY > -20)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        var fMouseInStartButton;
        function startMouseMoveDetect(ev)
        {
            var mouseX, mouseY;
            if (ev.layerX || ev.layerX == 0)
            {
                mouseX = ev.layerX;
                mouseY = ev.layerY;
            }
            else if (ev.offsetX || ev.offsetX == 0)
            {
                mouseX = ev.offsetX;
                mouseY = ev.offsetY;
            }
            if (mouseInStartButton(mouseX,mouseY))
            {
                fMouseInStartButton = true;
            }
            else
            {
                fMouseInStartButton = false;
            }
            drawPreScene();
        }

        function startMouseUpDetect(ev)
        {
            var mouseX, mouseY;
            if (ev.layerX || ev.layerX == 0)
            {
                mouseX = ev.layerX;
                mouseY = ev.layerY;
            }
            else if (ev.offsetX || ev.offsetX == 0)
            {
                mouseX = ev.offsetX;
                mouseY = ev.offsetY;
            }

            if (mouseInStartButton(mouseX,mouseY))
            {
                main_canvas.removeEventListener("mousemove",startMouseMoveDetect);
                main_canvas.removeEventListener("mouseup",startMouseUpDetect);
                gameInit();
            }
        }

        function drawPreScene()
        {
            main_context.fillStyle = "rgb(0,0,0)";
            main_context.strokeStyle = "rgb(0,0,0)";

            main_context.fillRect(0,0,MAIN_CONTEXT_WIDTH,MAIN_CONTEXT_HEIGHT);
            main_context.font = "italic 30px sans-serif";
            main_context.textAlign = "center";
            if (fMouseInStartButton)
            {
                main_context.fillStyle = "rgb(0,0,255)";
                main_context.strokeStyle = "rgb(0,0,255)";
            }
            else
            {
                main_context.fillStyle = "rgb(255,255,255)";
                main_context.strokeStyle = "rgb(255,255,255)";
            }
//            main_context.fillRect(0,0,MAIN_CONTEXT_WIDTH/2,MAIN_CONTEXT_HEIGHT/2);
            main_context.fillText('Start',MAIN_CONTEXT_WIDTH/2 - 10,MAIN_CONTEXT_HEIGHT/2);

            main_context.fillStyle = "rgb(0,0,0)";
            main_context.strokeStyle = "rgb(0,0,0)";

//            gameInit();

        }


        ////////////////////////////////////////////////////////////////////////
        //Game Logic
        function gameInit()
        {
            //bitmapArray
            for(var i = 0; i < GAME_AREA_WIDTH * GAME_AREA_HEIGHT; i++)
            {
                bitmapArray[i] = 0;
            }

            currentScore = 0;

            nextBlock = getRandomBlock();
            getNextBlock();

            gameRedraw();

            //key listener
            window.addEventListener('keydown',handleKeyDown,false);
//            main_canvas.addEventListener('keydown',handleKeyDown,false);

            //开始下落
            currentFallingInterval = 500;
            beginFalling();
        }


        function beginFalling()
        {
            fFalling = true;

            fallingCycleTag = window.setInterval(fallingCycle,currentFallingInterval);
        }
        function fallingCycle()
        {
            if (fFalling)
            {
                moveCurrentBlock(0,1);
            }
        }



        function getNextBlock()
        {
            currentBlock = nextBlock;
            nextBlock = getRandomBlock();
            blockPositionX = parseInt(GAME_AREA_WIDTH / 2 - 1);
            blockPositionY = 0;
        }

        ////////////////////////////////////
        //KeyBoard Handler
        function handleKeyDown(event)
        {

            var keyCode;
            if (event == null)
            {
                keyCode = window.event.keyCode;
                if(keyCode >= 37 && keyCode <= 40)
                {
                    window.event.preventDefault();
                }
            }
            else
            {
                keyCode = event.keyCode;
                if(keyCode >= 37 && keyCode <= 40)
                {
                    event.preventDefault();
                }
            }

            switch(keyCode)
            {
                case 37:        //Left
                        handleLeftKey();
//                      alert("Left");
                        break;
                case 38:        //Top
                        handleUpKey();
//                      alert("Top");
                    break;
                case 39:        //Right
                        handleRightKey();
//                      alert("Right");
                    break;
                case 40:        //Down
                        handleDownKey();
//                      alert("Down");
                    break;
            }
        }
        function handleUpKey()
        {
            currentBlock.rotate();
            if(detectConflict(0,0))
            {
                currentBlock.rotateBack();
            }
            gameRedraw();
        }
        function handleDownKey()
        {
            moveCurrentBlock(0,1);

        }
        function handleLeftKey()
        {
            moveCurrentBlock(-1,0);

        }
        function handleRightKey()
        {
            moveCurrentBlock(1,0);

        }

        ////////////////////////////////////
        //Detect
        function detectConflict(offsetX,offsetY)
        {
            var bLeft = getBlockLeft(currentBlock);
            var bRight = getBlockRight(currentBlock);
            var bBottom = getBlockBottom(currentBlock);

            if(parseInt(bRight + blockPositionX + offsetX) >= parseInt(GAME_AREA_WIDTH))
            {
                return true;
            }
            if(parseInt(bLeft + blockPositionX + offsetX) < parseInt(0))
            {
                return true;
            }
            if (parseInt(bBottom + blockPositionY + offsetY) >= parseInt(GAME_AREA_HEIGHT))
            {
                return true;
            }
            for (var i = 0; i < currentBlock.points.length; i++)
            {
                var bX = blockPositionX + currentBlock.points[i].x + offsetX;
                var bY = blockPositionY + currentBlock.points[i].y + offsetY;
                if (getBitMapInfo(bY, bX) != 0)
                {
                    return true;
                }
            }
            return false;
        }

        ////////////////////////////////////
        //Block Movement
        function moveCurrentBlock(mX, mY)       //mX = 1 or -1, mY = 1
        {
            if (!fFalling)
            {
                return;
            }
            if (mX == 1 && mY == 0)             //Move Right
            {
                if (!detectConflict(1,0))
                {
                    blockPositionX += 1;
                    gameRedraw();
                }
            }
            else if (mX == -1 && mY == 0)       //Move Left
            {
                if (!detectConflict(-1,0))
                {
                    blockPositionX -= 1;
                    gameRedraw();
                }
            }
            else if (mX == 0 && mY == 1)        //Move Down
            {
                if (detectConflict(0,1))
                {
                    addBlockToBitmap();
                    if (blockDetect())
                    {
                    }
                    else
                    {
                        getNextBlock();
                        gameRedraw();
                    }
                }
                else
                {
                    blockPositionY += 1;
                    gameRedraw();
                }
            }
        }
        function addBlockToBitmap()
        {
            for(var i = 0; i < currentBlock.points.length; i++)
            {
                var point = currentBlock.points[i];
                var x = point.x;
                var y = point.y;
                setBitMapInfo(blockPositionY + y, blockPositionX + x, currentBlock.color);

            }
        }

        //Draw
        function drawCurrentBlock()
        {
            drawBlock(GAME_AREA_LEFT + blockPositionX * BLOCK_SIZE, GAME_AREA_TOP + blockPositionY * BLOCK_SIZE, currentBlock, main_context);
        }

        function gameRedraw()
        {
            main_context.fillStyle = "rgb(0,0,0)";
            main_context.strokeStyle = "rgb(0,0,0)";

            main_context.fillRect(0,0,MAIN_CONTEXT_WIDTH,MAIN_CONTEXT_HEIGHT);
            //game area

            main_context.clearRect(GAME_AREA_LEFT, GAME_AREA_TOP,GAME_AREA_WIDTH * BLOCK_SIZE,GAME_AREA_HEIGHT * BLOCK_SIZE);

            for (var row = 0; row < GAME_AREA_HEIGHT; row++)
            {
                for (var column = 0; column < GAME_AREA_WIDTH; column++)
                {
                    var color = getBitMapInfo(row,column);
                    if(color > 0 )
                    {
                        var y = GAME_AREA_TOP + row * BLOCK_SIZE;
                        var x = GAME_AREA_LEFT + column * BLOCK_SIZE;
                        preBitMapImg(color,x,y,main_context);
                    }
                }
            }

            //Score area

            main_context.font = "italic 20px sans-serif";

            main_context.fillStyle = "rgb(255,255,255)";
            main_context.strokeStyle = "rgb(255,255,255)";

            main_context.fillText('Score', SCORE_TEXT_X, SCORE_TEXT_Y);
            main_context.fillText(currentScore, SCORE_NUMBER_X, SCORE_NUMBER_Y);


            //next area
            main_context.clearRect(NEXT_BLOCK_AREA_LEFT, NEXT_BLOCK_AREA_TOP, NEXT_BLOCK_AREA_WIDTH, NEXT_BLOCK_AREA_HEIGHT);
            drawBlock(NEXT_BLOCK_X, NEXT_BLOCK_Y, nextBlock, main_context);

            //currentBlock
            drawCurrentBlock();

            main_context.fillStyle = "rgb(0,0,0)";
            main_context.strokeStyle = "rgb(0,0,0)";

        }

        function preBitMapImg(color,x,y,context)
        {
            var imgName = getColorImage(color);
            var img = new Image();
            img.src = imgName;
            if (img.complete)
            {
                context.drawImage(img,x, y, BLOCK_SIZE, BLOCK_SIZE);
                return;
            }
            img.onload = function()
            {
                context.drawImage(img,x, y, BLOCK_SIZE, BLOCK_SIZE);
            };
        }

        //Detect
        function blockDetect()
        {
            var disappearArray = new Array;
            for (var row = 0; row < GAME_AREA_HEIGHT; row++)
            {
                var fDisappear = true;
                for (var column = 0; column < GAME_AREA_WIDTH; column++)
                {
                    if (getBitMapInfo(row,column) == 0)
                    {
                        fDisappear = false;
                        break;
                    }
                }
                if (fDisappear)
                {
                    disappearArray.push(row);
                }
            }

            if (disappearArray.length != 0)
            {
                //有方块需要消去
                fFalling = false;
                currentBlock = null;
                //加分
                currentScore += disappearArray.length * disappearArray.length * 100;
                for(var i = 0; i < disappearArray.length; i++)
                {
                    //加快下落速度
                    currentFallingInterval *= FALL_INTERVAL_CHANGE_RATE;
                }
                disppearBlock(disappearArray);
                window.clearInterval(fallingCycleTag);
                fallingCycleTag = window.setInterval(fallingCycle,currentFallingInterval);
                return true;
            }
            else
            {
                return false;
            }
        }

        function disppearBlock(rowArray)
        {
            for (var i = 0; i < rowArray.length; i++)
            {
                var row = rowArray[i];
                for(var j = 0; j < GAME_AREA_WIDTH; j++)
                {
                    setBitMapInfo(row,j,-1);
//                    alert(row);
                }
            }
            gameRedraw();
            setTimeout(disppearRestart,100);
        }
        function disppearRestart()
        {
            var copyFrom = GAME_AREA_HEIGHT - 1;
            for (var i = GAME_AREA_HEIGHT - 1; i >= 0; i--)
            {
                while(copyFrom >= 0 && getBitMapInfo(copyFrom,0) == -1)
                {
                    --copyFrom;
                }


                for (var j = 0; j < GAME_AREA_WIDTH; j++)
                {
                    var copyValue = 0;
                    if (copyFrom >= 0 )
                    {
                        copyValue = getBitMapInfo(copyFrom,j);
                    }
                    setBitMapInfo(i,j,copyValue);
                }
                --copyFrom;
            }
            getNextBlock();
            fFalling = true;
            gameRedraw();
        }



    </script>
</head>
<body onload="init()">

    <canvas width="400" height="380" id="main_canvas">
        Your browser doesn't support canvas, please change the browser.
    </canvas>
    <canvas width="200" height="100" id="sign_canvas">
        Your browser doesn't support canvas, please change the browser.
    </canvas>


    <!--预读取图片，防止游戏图片加载缓慢-->
    <img class="preloadImg" src="img/block_color_1.png" />
    <img class="preloadImg" src="img/block_color_2.png" />
    <img class="preloadImg" src="img/block_color_3.png" />
    <img class="preloadImg" src="img/block_color_4.png" />
    <img class="preloadImg" src="img/block_color_5.png" />
    <img class="preloadImg" src="img/block_color_6.png" />
    <img class="preloadImg" src="img/block_color_7.png" />


</body>
</html>